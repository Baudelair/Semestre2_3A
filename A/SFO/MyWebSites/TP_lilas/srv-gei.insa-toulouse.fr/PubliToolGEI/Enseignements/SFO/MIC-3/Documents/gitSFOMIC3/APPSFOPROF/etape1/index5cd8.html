<html>
<!-- Mirrored from srv-gei.insa-toulouse.fr/PubliToolGEI/Enseignements/SFO/MIC-3/Documents/gitSFOMIC3/APPSFOPROF/etape1/index.html?part=ID_PubliTool_N10445 by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 31 May 2018 14:00:57 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>&Eacute;tape 1&nbsp;:  Le cœur et les &micro;-s&eacute;quences</title><!--Généré dynamiquement par PubliTool 2009--><link href="../../../../../../../BASE/CSS/Article.css" rel="stylesheet"><script src="../../../../../../../BASE/JS/Article.js" type="text/javascript">
   </script><script src="../../../../../../../BASE/JS/Mozile08/mozile.js" type="text/javascript"></script><script type="text/javascript">
      mozile.root = "../../../../../../../BASE/JS/Mozile08";
      mozile.useSchema("../../../../../../../BASE/JS/xhtmlPubliTool.rng");
      mozile.help = "http://srv-gei.insa-toulouse.fr/PubliToolGEI/BASE/JS/Mozile08/doc/html/index.html";
     </script><script src="../../../../../../../BASE/JS/formulaire.js" type="text/javascript"></script><script src="../../../../../../../BASE/JS/mozilePubliTool.js" type="text/javascript"></script></head><body><div id="zoneBoutons"><table style="padding: 0px;border:0px;"><tr style="padding: 0px;border:0px;"><td style="padding: 0px;border:0px;"><a href="../index.html"><img xmlns:url="http://whatever/java/java.net.URLEncoder" src="../pucePRpetiteee0c.png?echelle=0.60"></a></td></tr></table></div><div class="zoneTitreCentr&eacute;e" id="titre">&Eacute;tape 1&nbsp;:  Le cœur et les &micro;-s&eacute;quences</div><div id="tocFixe"><ul><li class="niv0"><a href="index.html" onClick="return chargerURLsansHistorique(this)">&Eacute;tape 1&nbsp;:  Le cœur et les &micro;-s&eacute;quences</a></li><li class="niv1"><a href="index7081.html?part=ID_PubliTool_N10038" onClick="return chargerURLsansHistorique(this)">1 Comment marche le s&eacute;quenceur d'un cœur?</a></li><li class="niv1"><a href="index27d2.html?part=ID_PubliTool_N1006C" onClick="return chargerURLsansHistorique(this)">2 Ma&icirc;trise du simulateur</a></li><li class="niv2"><a href="index7baf.html?part=ID_PubliTool_N100C4" onClick="return chargerURLsansHistorique(this)">2.1 Ma&icirc;trise du &micro;-s&eacute;quenceur</a></li><li class="niv2"><a href="index7dc5.html?part=ID_PubliTool_N10118" onClick="return chargerURLsansHistorique(this)">2.2 Ma&icirc;trise du chemin des donn&eacute;es</a></li><li class="niv2"><a href="indexf185.html?part=ID_PubliTool_N102E3" onClick="return chargerURLsansHistorique(this)">2.3 La boucle Von Neumann</a></li><li class="niv1sel"><a href="index5cd8.html?part=ID_PubliTool_N10445" onClick="return chargerURLsansHistorique(this)">3 D&eacute;veloppement du jeu d'instructions et modes d'adressages</a></li><li class="niv1"><a href="index9d66.html?part=ID_PubliTool_N106A0" onClick="return chargerURLsansHistorique(this)">4 Ma&icirc;trise de la carte Nexys3</a></li><li class="niv1"><a href="index674d.html?part=ID_PubliTool_N10740" onClick="return chargerURLsansHistorique(this)">5 Application&nbsp;: pilotage d'un filtre audio</a></li></ul></div><div class="zoneMain"><p class="H2c" xmlns:url="http://whatever/java/java.net.URLEncoder">
   - 3 -</p><p class="H2c" xmlns:url="http://whatever/java/java.net.URLEncoder">D&eacute;veloppement du jeu d'instructions et modes d'adressages</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Il est clair que les deux instructions pr&eacute;c&eacute;dentes ne suffisent pas pour r&eacute;aliser n'importe quel algorithme. Il faut donc &eacute;tendre le <i>jeu d'instructions</i> avec diff&eacute;rentes op&eacute;rations (par exemple ADD, SUB, OR, LSHL, ...) mais aussi diff&eacute;rents modes d'adressage (imm&eacute;diat, direct, indirect, ...).</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Par exemple, l'instruction MOV Ra,Rb utilise un adressage par registre pour la source Rb et pour la cible Ra. Ce genre de mode d'adressage ne suffit pas car cela limite le nombre de variables d'un algorithme au nombre de registres &agrave; usage g&eacute;n&eacute;raux <strong>GPR</strong> (<i>General Purpose Registers</i>) de la machine  (dans notre cas les 8 registres R0 &agrave; R15)&nbsp;; de plus le programme ne peut ni initialiser les registres avec une valeur num&eacute;rique, ni communiquer vers l'ext&eacute;rieur puisqu'il n'a pas acc&egrave;s &agrave; l'espace m&eacute;moire o&ugrave; se trouve la RAM et les p&eacute;riph&eacute;riques.</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Pour initialiser les variables, acc&eacute;der &agrave; un grand nombre de variables dans la RAM ou acc&eacute;der &agrave; l'ext&eacute;rieur via un p&eacute;riph&eacute;rique, il faut ajouter des modes d'adressage (cf Polycopi&eacute; Chapitre 6.3) tels que ceux de la table  3.1.
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">
<table border="1" width="100%"><colgroup><col width="5cm"><col width="5cm"><col width="5cm"></colgroup><thead><th><b>Mode d'adressage</b></th><th><b>Fonction</b></th><th><b>Notation courante</b></th></thead><tr><td>registre</td><td>Ra &larr; Rb</td><td> Ra, Rb</td></tr><tr><td>imm&eacute;diat</td><td>Ra &larr; imm16</td><td> Ra, #imm16</td></tr><tr><td>direct</td><td>Ra &larr; <span style="font-family:URW Chancery L;font-size:xx-large;font-style:italic;">M</span>[imm16]</td><td> Ra, [#imm16]</td></tr><tr><td>indirect</td><td>Ra &larr; <span style="font-family:URW Chancery L;font-size:xx-large;font-style:italic;">M</span>[Rb]</td><td> Ra, [Rb]</td></tr></table><p style="top:10pt;bottom:5mm;text-align:justify;"></p><div class="centr&eacute;e">Tab 3.1  : Quelques modes d'adressages appliqu&eacute;s au second op&eacute;rande (Rb).</div>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Le mode d'adressage est impos&eacute; par le code op&eacute;ration de l'instruction.</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Les instructions de cette machine se pr&eacute;sentent sous 3 formats diff&eacute;rents&nbsp;:
<ul id="ID_PubliTool_N104BF">
<li><p style="text-align:justify;">Format 1&nbsp;: <embed src="doc/FormatInstruction1.svg" type="image/svg+xml"></embed></p>
<p style="top:10pt;bottom:5mm;text-align:justify;">Ce format concerne les instructions op&eacute;rant sur des registres</p></li>
<li><p style="text-align:justify;">Format 2&nbsp;: <embed src="doc/FormatInstruction2.svg" type="image/svg+xml"></embed></p>
<p style="top:10pt;bottom:5mm;text-align:justify;">Ce format concerne les instructions qui n&eacute;cessitent une valeur sign&eacute;e sur 8 bits. C'est le cas de toutes les instructions de branchement conditionnel (BR, BZ, ...).</p></li>
<li><p style="text-align:justify;">Format 3&nbsp;: <embed src="doc/FormatInstruction3.svg" type="image/svg+xml"></embed></p>
<p style="top:10pt;bottom:5mm;text-align:justify;">Ce format est utilis&eacute; par les instructions n&eacute;cessitant une valeur sur 16 bits (LDI, CALL, ..). Dans ce cas, l'instruction est cod&eacute;e sur deux mots cons&eacute;cutifs de 16 bits, le deuxi&egrave;me mot &eacute;tant l'op&eacute;rande sur 16 bits.</p></li>
</ul>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Le tableau ci-dessous, r&eacute;sume l'ensemble des instructions pouvant &ecirc;tre ex&eacute;cut&eacute;es par notre machine. La colonne "Hexa" donne le codage de l'instruction (le premier chiffre correspond au COP, le deuxi&egrave;me chiffre correspond au SCO, les param&egrave;tres variables (num&eacute;ro de registre, donn&eacute;e sign&eacute;e sur 8 bits, donn&eacute;e sur 16 bits) sont indiqu&eacute;es par un ou plusieurs lettres correspondant au champ utilis&eacute;. La colonne "Assembleur" indique le format de l'instruction &eacute;crite dans le langage d'assemblage. 
La colonne "Action" indique exactement ce que fait l'instruction (apr&egrave;s le fetch qui fait au pr&eacute;alable PC&larr;PC+2, pour toutes les instructions). Enfin, la colonne CNZV indique si l'instruction modifie le registre condition ou non.
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">
<table border="1"><thead><th bgcolor="#AEC4E8"><b>Hexa</b></th><th bgcolor="#AEC4E8"><b>Assembleur</b></th><th bgcolor="#AEC4E8"><b>Action</b></th><th bgcolor="#AEC4E8"><b>CNZV</b></th></thead><tr><td bgcolor="94c2ec">11ab</td><td bgcolor="#C4E8E8">ADD&nbsp;Ra, Rb</td><td>Ra &lt;- Ra + Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">12ab</td><td bgcolor="#C4E8E8">SUB&nbsp;Ra, Rb</td><td>Ra &lt;- Ra - Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">13ab</td><td bgcolor="#C4E8E8">COPY&nbsp;Ra, Rb</td><td>Ra &lt;- Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">14ab</td><td bgcolor="#C4E8E8">OR&nbsp;Ra, Rb</td><td>Ra &lt;- Ra or Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">15ab</td><td bgcolor="#C4E8E8">XOR&nbsp;Ra, Rb</td><td>Ra &lt;- Ra xor Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">16ab</td><td bgcolor="#C4E8E8">AND&nbsp;Ra, Rb</td><td>Ra &lt;- Ra and Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">17ab</td><td bgcolor="#C4E8E8">NOT&nbsp;Ra, Rb</td><td>Ra &lt;- not Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">20ab</td><td bgcolor="#C4E8E8">LSR&nbsp;Ra, Rb</td><td>Ra &lt;- d&eacute;calage simple droit Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">21ab</td><td bgcolor="#C4E8E8">LSL&nbsp;Ra, Rb</td><td>Ra &lt;- d&eacute;calage simple gauche Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">22ab</td><td bgcolor="#C4E8E8">ASR&nbsp;Ra, Rb</td><td>Ra &lt;- d&eacute;calage arithm&eacute;tique droit Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">23ab</td><td bgcolor="#C4E8E8">ASL&nbsp;Ra, Rb</td><td>Ra &lt;- d&eacute;calage arithm&eacute;tique gauche Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">24ab</td><td bgcolor="#C4E8E8">CSR&nbsp;Ra, Rb</td><td>Ra &lt;- d&eacute;calage circulaire droit  Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">25ab</td><td bgcolor="#C4E8E8">CSL&nbsp;Ra, Rb</td><td>Ra &lt;- d&eacute;calage circulaire gauche Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">26ab</td><td bgcolor="#C4E8E8">CSRC&nbsp;Ra, Rb</td><td>Ra,C &lt;- d&eacute;calage circulaire droit Rb,C</td><td>oui</td></tr><tr><td bgcolor="94c2ec">27ab</td><td bgcolor="#C4E8E8">CSLC&nbsp;Ra, Rb</td><td>Ra,C &lt;- d&eacute;calage circulaire gauche  Rb,C</td><td>oui</td></tr><tr><td bgcolor="94c2ec">30ab</td><td bgcolor="#C4E8E8">MOV&nbsp;Ra, Rb</td><td>Ra &lt;- Rb </td><td></td></tr><tr><td bgcolor="94c2ec">31ab</td><td bgcolor="#C4E8E8">CMP&nbsp;Ra, Rb</td><td> &lt;- Ra - Rb</td><td>oui</td></tr><tr><td bgcolor="94c2ec">32ab</td><td bgcolor="#C4E8E8">MUL&nbsp;Ra, Rb</td><td>Ra,Rb &lt;- Ra x Rb</td><td></td></tr><tr><td bgcolor="94c2ec">33ab</td><td bgcolor="#C4E8E8">DIV&nbsp;Ra, Rb</td><td>Ra,Rb &lt;- Ra / Rb, Ra rem Rb</td><td></td></tr><tr><td bgcolor="f6adaa">40a- dddd</td><td bgcolor="#C4E8E8">LD&nbsp;Ra, [#adr16b]</td><td>Ra &lt;- M&eacute;moire[dddd]</td><td></td></tr><tr><td bgcolor="f6adaa">41a- dddd</td><td bgcolor="#C4E8E8">LDI&nbsp;Ra, #data16b</td><td>Ra &lt;- dddd</td><td></td></tr><tr><td bgcolor="f6adaa">42a- dddd</td><td bgcolor="#C4E8E8">ST&nbsp;Ra, [#adr16b]</td><td>Ra -&gt; M&eacute;moire[dddd]</td><td></td></tr><tr><td bgcolor="94c2ec">43ab</td><td bgcolor="#C4E8E8">LDR&nbsp;Ra, [Rb]</td><td>Ra &lt;- M&eacute;moire[Rb]</td><td></td></tr><tr><td bgcolor="94c2ec">44ab</td><td bgcolor="#C4E8E8">STR&nbsp;Ra, [Rb]</td><td>Ra -&gt; M&eacute;moire[Rb]</td><td></td></tr><tr><td bgcolor="f6adaa">4Aa- dddd</td><td bgcolor="#C4E8E8">LDB&nbsp;Ra, [#adr16b]</td><td>Ra &lt;- (BYTE) M&eacute;moire[dddd]</td><td></td></tr><tr><td bgcolor="f6adaa">4Ca- dddd</td><td bgcolor="#C4E8E8">STB&nbsp;Ra, [#adr16b]</td><td>Ra -&gt; (BYTE) M&eacute;moire[dddd]</td><td></td></tr><tr><td bgcolor="94c2ec">4Dab</td><td bgcolor="#C4E8E8">LDRB&nbsp;Ra, [Rb]</td><td>Ra &lt;- (BYTE) M&eacute;moire[Rb]</td><td></td></tr><tr><td bgcolor="94c2ec">4Eab</td><td bgcolor="#C4E8E8">STRB&nbsp;Ra, [Rb]</td><td>Ra -&gt; (BYTE) M&eacute;moire[Rb]</td><td></td></tr><tr><td bgcolor="94c2ec">45a-</td><td bgcolor="#C4E8E8">PUSH&nbsp;Ra</td><td>Mem(--SP) &lt;- Ra</td><td></td></tr><tr><td bgcolor="94c2ec">46a-</td><td bgcolor="#C4E8E8">POP&nbsp;Ra</td><td>Mem(SP++) -&gt; Ra</td><td></td></tr><tr><td bgcolor="94c2ec">47a-</td><td bgcolor="#C4E8E8">LDCC&nbsp;Ra</td><td>Ra &lt;- CNZV</td><td></td></tr><tr><td bgcolor="94c2ec">48a-</td><td bgcolor="#C4E8E8">STCC&nbsp;Ra</td><td>Ra -&gt; CNZV</td><td>oui</td></tr><tr><td bgcolor="94ecc0">50--</td><td bgcolor="#C4E8E8">NOP&nbsp;--</td><td>Non op&eacute;ration</td><td></td></tr><tr><td bgcolor="94ecc0">51dd</td><td bgcolor="#C4E8E8">B&nbsp;dd</td><td>PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">52dd</td><td bgcolor="#C4E8E8">BN&nbsp;dd</td><td>si N alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">53dd</td><td bgcolor="#C4E8E8">BNN&nbsp;dd</td><td>si not N alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">54dd</td><td bgcolor="#C4E8E8">BV&nbsp;dd</td><td>si V alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">55dd</td><td bgcolor="#C4E8E8">BNV&nbsp;dd</td><td>si not V alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">56dd</td><td bgcolor="#C4E8E8">BZ&nbsp;dd</td><td>si &eacute;gal alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">57dd</td><td bgcolor="#C4E8E8">BNZ&nbsp;dd</td><td>si diff&eacute;rent alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">58dd</td><td bgcolor="#C4E8E8">BG&nbsp;dd</td><td>si plus grand (nombres sign&eacute;s) alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">59dd</td><td bgcolor="#C4E8E8">BLE&nbsp;dd</td><td>si plus petit ou egal (nombres sign&eacute;s) alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">5Add</td><td bgcolor="#C4E8E8">BGE&nbsp;dd</td><td>si plus grand ou &eacute;gal (nombres sign&eacute;s) alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">5Bdd</td><td bgcolor="#C4E8E8">BL&nbsp;dd</td><td>si plus petit (nombres sign&eacute;s)alors  PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">5Cdd</td><td bgcolor="#C4E8E8">BGNS&nbsp;dd</td><td>si plus grand (nombres non sign&eacute;s) alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">5Ddd</td><td bgcolor="#C4E8E8">BLENS&nbsp;dd</td><td>si plus petit ou &eacute;gal (nombres non sign&eacute;s) alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">5Edd</td><td bgcolor="#C4E8E8">BNC&nbsp;dd</td><td>si plus grand ou &eacute;gal (nombres non sign&eacute;s) alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="94ecc0">5Fdd</td><td bgcolor="#C4E8E8">BC&nbsp;dd</td><td>si plus petit (nombres non sign&eacute;s) alors PC &lt;- PC + ExtSign16(dd)</td><td></td></tr><tr><td bgcolor="f6adaa">60-- dddd</td><td bgcolor="#C4E8E8">CALL&nbsp;#adr16b</td><td>Mem(--SP) &lt;- PC, PC &lt;- dddd</td><td></td></tr><tr><td bgcolor="94c2ec">61--</td><td bgcolor="#C4E8E8">RETURN&nbsp;</td><td>Mem(SP++) -&gt; PC</td><td></td></tr><tr><td bgcolor="94c2ec">62--</td><td bgcolor="#C4E8E8">RTI&nbsp;</td><td>Retour d'interruption</td><td></td></tr></table>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Deux commandes permettent de contr&ocirc;ler le transfert des donn&eacute;es via le bus (voir figure ci-dessous)&nbsp;:
<ul id="ID_PubliTool_N104EE">
<li>MO&nbsp;: pour sp&eacute;cifier la taille de l'&eacute;change, Mot (MO=0) ou Octet (MO=1)</li>
<li>LE&nbsp;: pour sp&eacute;cifier le sens de l'&eacute;change, Lecture (LE=0) ou &eacute;criture (LE=1)</li>
</ul>

Lors de l'&eacute;change d'un octet en lecture (sens bus vers coeur), le bit de fort poids de l'octet est &eacute;tendu pour obtenir un mot sur 16 bits. Par exemple la lecture de l'octet 0x72 permettra de recevoir sur le bus la valeur sur 16 bits 0x0072, tandis que la lecture de l'octet 0x82 permettra de recevoir sur le bus la valeur sur 16 bits 0xFF82.
<div class="centr&eacute;e"><embed src="doc/EchangeMotOctet23f0.svg?echelle=0.8" type="image/svg+xml"></embed></div><div class="centr&eacute;e"> Fig 3.1  : Commande pour l'&eacute;change via le bus</div>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Le champ SCO de l'instruction est directement connect&eacute; sur le chemin de donn&eacute;e et permet de piloter soit le choix de l'indicateur qui sera transmis &agrave; la partie microcontrole, soit le choix de l'op&eacute;ration effectu&eacute;e par l'unit&eacute; arithm&eacute;tique et logique. La table ci-dessous r&eacute;sume les diff&eacute;rentes op&eacute;rations possibles&nbsp;:
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">
<table border="1"><thead><th><b>SCO</b></th><th><b>Indic ALU</b></th><th><b>Fct ALU</b></th><th><b>Fct D&eacute;caleur</b></th></thead><tr><td>0x0</td><td>F</td><td>A</td><td>d&eacute;cal. simple droit(B)</td></tr><tr><td>0x1</td><td>V</td><td>A + B</td><td>d&eacute;cal. simple gauche(B)</td></tr><tr><td>0x2</td><td>N</td><td>A - B</td><td>d&eacute;cal. arith. droit(B)</td></tr><tr><td>0x3</td><td>&not; N</td><td>B</td><td>d&eacute;cal. arith. gauche(B)</td></tr><tr><td>0x4</td><td>V</td><td>A &or; B</td><td>d&eacute;cal. circ. droit(B)</td></tr><tr><td>0x5</td><td>&not; V</td><td>A &oplus; B</td><td>d&eacute;cal. circ. gauche(B)</td></tr><tr><td>0x6</td><td>A=B, Z</td><td>A &and; B</td><td>d&eacute;cal. circ. droit(B,C)</td></tr><tr><td>0x7</td><td>A#B, &not; Z</td><td>&not; B</td><td>d&eacute;cal. circ. gauche(B,C)</td></tr><tr><td>0x8</td><td>A&gt;B pour les nombres sign&eacute;s, &not; (V &oplus; N) &and; &not; Z</td><td>P&larr;0, Aalu&larr;X, Balu&larr;Y</td><td>nop</td></tr><tr><td>0x9</td><td>A&le;B pour les nombres sign&eacute;s, (V &oplus; N) &or; Z</td><td>P</td><td>nop</td></tr><tr><td>0xA</td><td>A&ge;B pour les nombres sign&eacute;s, &not; (V &oplus; N)</td><td>Aalu</td><td>nop</td></tr><tr><td>0xB</td><td>A&lt;B pour les nombres sign&eacute;s, V &oplus; N</td><td>Balu</td><td>nop</td></tr><tr><td>0xC</td><td>A&gt;B pour les nombres non sign&eacute;s, &not; (C &or; Z)</td><td>cycle mult</td><td>nop</td></tr><tr><td>0xD</td><td>A &le; B pour les nombres non sign&eacute;s, C &or; Z</td><td>cycle div</td><td>nop</td></tr><tr><td>0xE</td><td>A&ge;B pour les nombres non sign&eacute;s, &not; C</td><td>Aalu &harr; Y </td><td>nop</td></tr><tr><td>0xF</td><td>A &lt; B pour les nombres non sign&eacute;s, C</td><td>Balu &harr; Y</td><td>nop</td></tr></table><p style="top:10pt;bottom:5mm;text-align:justify;"></p><div class="centr&eacute;e">Tab 3.2  : Codage du SCO</div>

</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder"><div class="" style="background-color:#FFCCFF;margin-top:1cm;margin-bottom:1cm;margin-left:0.25cm;margin-right:0.25cm"><strong>Travail&nbsp;: Instructions CMP et instructions utilisant l'ALU</strong><i><p style="text-align:justify;">
Impl&eacute;mentez par microprogrammation l'instruction CMP (COP/SCO=0x31), les instructions arithm&eacute;tiques et logiques (COP=0x1) et les instructions de d&eacute;calages (COP=0x2).
</p><p style="top:10pt;bottom:5mm;text-align:justify;">Si vous &ecirc;tes astucieux, vous utiliserez le m&ecirc;me microprogramme (celui de l'instruction B) pour toutes les instructions de branchement (utilisez dans le chemin de donn&eacute;es le champ SCO pour d&eacute;finir le choix de l'indicateur ALU &agrave; utiliser).</p><p style="top:10pt;bottom:5mm;text-align:justify;">De la m&ecirc;me mani&egrave;re, soyez astucieux pour microprogrammer les instructions arithm&eacute;tiques, logiques ou de d&eacute;calage (utilisez dans le chemin de donn&eacute;es le champ SCO pour d&eacute;finir l'op&eacute;ration sur l'ALU).</p></i></div></p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Pour vous faciliter l'initialisation de la m&eacute;moire de programme (Rom), vous pouvez utiliser le langage d'assemblage fourni. Il suffit d'&eacute;crire votre programme dans un fichier ayant pour extension <span style="font-family:monospace;">ass</span> au lieu de l'extension <span style="font-family:monospace;">mem</span> utilis&eacute;e pour les images m&eacute;moire. Par exemple, voici un petit programme permettant de tester les instructions pr&eacute;c&eacute;dentes (ce programme sera &eacute;crit dans le fichier RomProgramme.ass) fourni&nbsp;:
<div style="white-space:pre;font-family:monospace;">
    	ORG		0x0
	WORD    0x400	; initialisation SP
	WORD	debut	; initialisation PC

debut:	
    	ADD     R1, R2
	CMP     R1, R2
	BC      retenue
fin1:   B       fin1
retenue:ASR     R1
fin2:   B       fin2
</div>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Pour utiliser cet assembleur, voir  tutoriel sur le <a href="../tutoriel_assembleur/index.html">langage d'assemblage</a>.
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder"><div class="" style="background-color:#FFCCFF;margin-top:1cm;margin-bottom:1cm;margin-left:0.25cm;margin-right:0.25cm"><strong>Travail&nbsp;: Instructions sur 2 mots</strong><i><p style="text-align:justify;">
Impl&eacute;mentez par microprogrammation les instructions LDI, LD et ST. Attention de ne pas &eacute;craser le contenu des registres non impliqu&eacute;s par l'instruction (&agrave; ce sujet, voir <a href="../aide/index8ba1.html?part=sauvegardeRegistres">sauvegarde registres dans l'ALU</a>).
</p><p style="top:10pt;bottom:5mm;text-align:justify;">
Dans un deuxi&egrave;me temps, impl&eacute;mentez par microprogrammation les instructions LDB et STB (si vous &ecirc;tes astucieux, vous irez tr&egrave;s vite en modifiant simplement un seul bit par instruction dans une copie du microcode de LD, ST).
</p></i></div></p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Pour faciliter le test de ces instructions, vous pouvez utiliser le programme suivant permettant de lire une valeur sur les 8 cl&eacute;s de la carte Nexys3, puis d'afficher cette valeur sur les afficheurs 7 segments ainsi que toutes les valeurs jusqu'&agrave; z&eacute;ro et terminer en bouclant sur l'allumage des 8 leds&nbsp;:
<div class="" style="white-space:pre;background-color:#e7e3e7;margin:1cm"> <span style="background:#99FF66"><a href="prog3.html">prog3.ass</a> : </span><div class="" style="white-space:pre;font-family:monospace;background-color:#e7e3e7;margin-top:0.2cm;margin-left:1cm">    	ORG	0x0
	WORD    0x400	; initialisation SP
	WORD	debut	; initialisation PC

SW:	EQU 	0x4000
BTN:	EQU 	0x4001
LED:    EQU 	0x4002
MODE:   EQU 	0x4003
DigitHexa:EQU 	0x4004

debut:	
        ; R1 initialis&eacute; &agrave; 1
        LDI     R1, #0x0001
        ; lecture des switch dans R0
        LDB     R0, [#SW]
boucle: 
        ; on affiche R0 sur les afficheurs 7-segments
        ST      R0, [#DigitHexa]
	; on d&eacute;cr&eacute;mente R0
	SUB     R0, R1
        ; on boucle si on n'a pas de retenue
	BNC     boucle
fin:    ; on affiche R0 sur les lesd (R0 est &eacute;gal &agrave; 0xFFFF)
	STB     R0, [#LED]
	B       fin
</div></div>

</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder"><div class="" style="background-color:#FFCCFF;margin-top:1cm;margin-bottom:1cm;margin-left:0.25cm;margin-right:0.25cm"><strong>Travail&nbsp;: Adressage indirect par registre</strong><i><p style="text-align:justify;">
Impl&eacute;mentez par microprogrammation les instructions LDR et STR. Puis, apr&egrave;s duplication et modification rapide du microcode obtenu, obtenez les instructions LDRB et STRB.
</p></i></div></p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Pour faciliter le test de ces instructions, vous pouvez utiliser le programme suivant permettant d'appliquer le masque de remise &agrave; z&eacute;ro sur 10 premiers mots de la m&eacute;moire RAM (le masque de remise &agrave; z&eacute;ro se trouve &agrave; l'adresse <span style="font-family:monospace;">mask</span> de la rom; un bit &agrave; 0 indique que le bit correspondant de la m&eacute;moire sera remis &agrave; 0; un bit &agrave; 1 indique que le bit correspondant de la m&eacute;moire sera conserv&eacute;).
<div class="" style="white-space:pre;background-color:#e7e3e7;margin:1cm"> <span style="background:#99FF66"><a href="prog4.html">prog4.ass</a> : </span><div class="" style="white-space:pre;font-family:monospace;background-color:#e7e3e7;margin-top:0.2cm;margin-left:1cm">    	ORG	0x0
	WORD    0x400	; initialisation SP
	WORD	debut	; initialisation PC

valInit:WORD	0x1234
mask:   WORD    0x0FF0  ; masque de remise &agrave; z&eacute;ro
debut:	LDI     R0, #0x0200 ; adresse premier mot de la ram
        LDI     R1, #0x0209 ; adresse dixi&egrave;me mot de la ram
        LDI     R2, #0x0002 ; valeur d'incr&eacute;mentation de l'adresse (2)
        LD      R3, [#valInit]
boucle: LDR     R4, [R0]
        AND     R4, R3
        STR     R3, [R0]
        CMP     R0, R1
        BZ      fin
        ADD     R0, R2
        B       boucle
fin:    B       fin
 </div></div>

</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder"><div class="" style="background-color:#99FFFF;margin-top:1cm;margin-bottom:1cm;margin-left:0.25cm;margin-right:0.25cm"><strong>Testez vos comp&eacute;tences sur <a href="doc/Exercice1.html">B imm8 et B imm16</a></strong></div></p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder"><div class="" style="background-color:#99FFFF;margin-top:1cm;margin-bottom:1cm;margin-left:0.25cm;margin-right:0.25cm"><strong>Testez vos comp&eacute;tences sur <a href="doc/Exercice2.html">Adressage &agrave; l'octet</a></strong></div></p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder"><div class="" style="background-color:#99FFFF;margin-top:1cm;margin-bottom:1cm;margin-left:0.25cm;margin-right:0.25cm"><strong>Testez vos comp&eacute;tences sur <a href="doc/Exercice6.html">Assemblage d'instructions inconnues de l'assembleur</a></strong></div></p></div></body>
<!-- Mirrored from srv-gei.insa-toulouse.fr/PubliToolGEI/Enseignements/SFO/MIC-3/Documents/gitSFOMIC3/APPSFOPROF/etape1/index.html?part=ID_PubliTool_N10445 by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 31 May 2018 14:01:05 GMT -->
</html>