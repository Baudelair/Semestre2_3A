<html>
<!-- Mirrored from srv-gei.insa-toulouse.fr/PubliToolGEI/Enseignements/SFO/MIC-3/Documents/gitSFOMIC3/APPSFOPROF/etape1/index.html?part=ID_PubliTool_N102E3 by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 31 May 2018 14:00:52 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>&Eacute;tape 1&nbsp;:  Le cœur et les &micro;-s&eacute;quences</title><!--Généré dynamiquement par PubliTool 2009--><link href="../../../../../../../BASE/CSS/Article.css" rel="stylesheet"><script src="../../../../../../../BASE/JS/Article.js" type="text/javascript">
   </script><script src="../../../../../../../BASE/JS/Mozile08/mozile.js" type="text/javascript"></script><script type="text/javascript">
      mozile.root = "../../../../../../../BASE/JS/Mozile08";
      mozile.useSchema("../../../../../../../BASE/JS/xhtmlPubliTool.rng");
      mozile.help = "http://srv-gei.insa-toulouse.fr/PubliToolGEI/BASE/JS/Mozile08/doc/html/index.html";
     </script><script src="../../../../../../../BASE/JS/formulaire.js" type="text/javascript"></script><script src="../../../../../../../BASE/JS/mozilePubliTool.js" type="text/javascript"></script></head><body><div id="zoneBoutons"><table style="padding: 0px;border:0px;"><tr style="padding: 0px;border:0px;"><td style="padding: 0px;border:0px;"><a href="../index.html"><img xmlns:url="http://whatever/java/java.net.URLEncoder" src="../pucePRpetiteee0c.png?echelle=0.60"></a></td></tr></table></div><div class="zoneTitreCentr&eacute;e" id="titre">&Eacute;tape 1&nbsp;:  Le cœur et les &micro;-s&eacute;quences</div><div id="tocFixe"><ul><li class="niv0"><a href="index.html" onClick="return chargerURLsansHistorique(this)">&Eacute;tape 1&nbsp;:  Le cœur et les &micro;-s&eacute;quences</a></li><li class="niv1"><a href="index7081.html?part=ID_PubliTool_N10038" onClick="return chargerURLsansHistorique(this)">1 Comment marche le s&eacute;quenceur d'un cœur?</a></li><li class="niv1"><a href="index27d2.html?part=ID_PubliTool_N1006C" onClick="return chargerURLsansHistorique(this)">2 Ma&icirc;trise du simulateur</a></li><li class="niv2"><a href="index7baf.html?part=ID_PubliTool_N100C4" onClick="return chargerURLsansHistorique(this)">2.1 Ma&icirc;trise du &micro;-s&eacute;quenceur</a></li><li class="niv2"><a href="index7dc5.html?part=ID_PubliTool_N10118" onClick="return chargerURLsansHistorique(this)">2.2 Ma&icirc;trise du chemin des donn&eacute;es</a></li><li class="niv2sel"><a href="indexf185.html?part=ID_PubliTool_N102E3" onClick="return chargerURLsansHistorique(this)">2.3 La boucle Von Neumann</a></li><li class="niv1"><a href="index5cd8.html?part=ID_PubliTool_N10445" onClick="return chargerURLsansHistorique(this)">3 D&eacute;veloppement du jeu d'instructions et modes d'adressages</a></li><li class="niv1"><a href="index9d66.html?part=ID_PubliTool_N106A0" onClick="return chargerURLsansHistorique(this)">4 Ma&icirc;trise de la carte Nexys3</a></li><li class="niv1"><a href="index674d.html?part=ID_PubliTool_N10740" onClick="return chargerURLsansHistorique(this)">5 Application&nbsp;: pilotage d'un filtre audio</a></li></ul></div><div class="zoneMain"><p class="H2c" xmlns:url="http://whatever/java/java.net.URLEncoder">
   - 2.3 -</p><p class="H2c" xmlns:url="http://whatever/java/java.net.URLEncoder">La boucle Von Neumann</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">
Une fois initialis&eacute;, le cœur ex&eacute;cute le programme contenu dans la
ROM en proc&eacute;dant en trois &eacute;tapes&nbsp;:  fetch, decode, execute.
<div class="centr&eacute;e"><embed src="doc/graphe-boucle-von-neumann23f0.svg?echelle=0.8" type="image/svg+xml"></embed></div>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">
<table border="1" width="100%"><colgroup><col width="3cm"><col width="2.cm"><col width="6cm"><col width="6cm"></colgroup><tr><td>Phase</td><td>&micro;@</td><td>&micro;-commande du s&eacute;quenceur</td><td>&micro;-commande du chemin de donn&eacute;es</td></tr><tr><td>fetch</td><td>0xF0,.., 0xFi, 0xFF</td><td>... &micro;@ &larr; 0x08</td><td>RI &larr; <span style="font-family:URW Chancery L;font-size:xx-large;font-style:italic;">M</span>[PC], PC &larr; PC+2</td></tr><tr><td>MOV Ra,Rb</td><td>0x08</td><td>&micro;@ &larr; 0xF0</td><td>Ra
&larr; Rb</td></tr></table><p style="top:10pt;bottom:5mm;text-align:justify;"></p><div class="centr&eacute;e">Tab 2.2  : La suite de la ROM de &micro;-code  avec les &micro;-s&eacute;quences de fetch et d'ex&eacute;cution des instructions</div>
Remarque&nbsp;: Le signe <span style="font-family:URW Chancery L;font-size:xx-large;font-style:italic;">M</span>[val] d&eacute;signe l'acc&egrave;s dans l'espace m&eacute;moire &agrave; l'adresse <i>val</i>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">&Agrave; la &micro;@0x8 figure le &micro;-code de l'instruction <span style="font-family:monospace;">MOV Ra, Rb</span> qui constitue les trois premi&egrave;res lignes du programme que l'on se propose d'implanter&nbsp;:
<div style="white-space:pre;font-family:monospace;">
loop:	;; 	swap R1 et R2 via R3
	MOV	R3, R1 &nbsp;; R3 &larr; R1
	MOV	R1, R2 &nbsp;; R1 &larr; R2
	MOV	R2, R3 &nbsp;; R2 &larr; R3
	B	loop
</div>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Le COP (Code OP&eacute;ration) et SCO (Sous Code Op&eacute;ration) de l'instruction <span style="font-family:monospace;">MOV Ra, Rb</span> est 0x30&nbsp;: pour coder en binaire cette instruction sur 16 bits il faudra compl&eacute;ter les 8 bits du COP/SCO par 8 bits servant &agrave; indiquer les registres cible et source (cf Chapitre 6.2). Remarquez que ce m&ecirc;me &micro;-code doit fonctionner aussi bien pour le <span style="font-family:monospace;">MOV R1, R3</span> que pour le <span style="font-family:monospace;">MOV R2, R1</span> ou <span style="font-family:monospace;">MOV R3, R2</span>: il faudra donc utiliser le c&acirc;blage (effectu&eacute; en dur dans le cœur, voir figure  2.1) des 8 bits de poids faible de RI vers les s&eacute;lecteurs de registre de la banque de registres.
<div class="centr&eacute;e"><embed src="doc/MovRaRbd627.svg?echelle=0.7" type="image/svg+xml"></embed></div><div class="centr&eacute;e"> Fig 2.1  : C&acirc;blage des champs de bits A et B vers les s&eacute;lecteurs de la banque de registres</div>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder"><div class="" style="background-color:#FFCCFF;margin-top:1cm;margin-bottom:1cm;margin-left:0.25cm;margin-right:0.25cm"><strong>Travail&nbsp;: Fetch, programmation et &micro;-programmation du MOV Ra,Rb</strong><i><p style="text-align:justify;">Donnez le code ex&eacute;cutable (<strong>byte code</strong> en anglais) des trois instructions du programme et implantez-les dans la m&eacute;moire &agrave; l'endroit 
correspondant &agrave; l'initialisation de la machine que vous avez faite. Vous &micro;-programmerez ensuite le fetch et v&eacute;rifierez que le chargement de RI avec 
le code ex&eacute;cutable de la premi&egrave;re instruction est correct et que le PC pointe bien sur la prochaine instruction. Terminez votre premier programme en 
&micro;-programmant l'instruction <span style="font-family:monospace;">MOV Ra,Rb</span> &agrave; la &micro;@0x08.  Que fait un cœur vaillant lorsque la derni&egrave;re instruction du programme est ex&eacute;cut&eacute;e&nbsp;?</p></i></div></p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder"><i>Remarque&nbsp;: pour le fetch, une seule microinstruction ne suffit pas  (@F0) puisque la
lecture de l'instruction en m&eacute;moire n&eacute;cessite plusieurs &eacute;tapes
(conform&eacute;ment au protocole d'utilisation du bus pr&eacute;sent&eacute; lors de la
phase d'initialisation).</i></p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Il est donc n&eacute;cessaire de rajouter l'instruction de saut relatif  <span style="font-family:monospace;">B &eacute;tiquette</span> pour ma&icirc;triser le flot d'ex&eacute;cution d'un cœur vaillant.
Cette instruction de saut est cod&eacute;e par <span style="font-family:monospace;">0x51imm8</span> o&ugrave; <i>imm8</i> est le d&eacute;placement relatif (8 bits sign&eacute;s) &agrave; ajouter au compteur ordinal PC pour d&eacute;tourner le flot d'ex&eacute;cution du cœur au "bon endroit" rep&eacute;r&eacute; par l'&eacute;tiquette <span style="font-family:monospace;">loop</span>.</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Le programme ex&eacute;cutable ressemblera donc &agrave;&nbsp;:
<table border="1" width="100%"><colgroup><col width="3cm"><col width="5cm"><col width="7cm"></colgroup><thead><th><b>Adresse</b></th><th><b>Code ex&eacute;cutable (byte code)</b></th><th><b>Assembleur</b></th></thead><tr><td> loop - 2 	</td><td>  0x???? 	</td><td> instruction pr&eacute;c&eacute;dente		</td></tr><tr><td> loop 	</td><td>  0x30??		</td><td> mov R3,R1				</td></tr><tr><td> loop + 2 	</td><td> 0x30??		</td><td> mov R1,R2				</td></tr><tr><td> loop + 4 	</td><td> 0x30??		</td><td> mov R2,R3				</td></tr><tr><td> loop + 6 	</td><td> 0x51??		</td><td> B loop					</td></tr><tr><td> loop + 8	</td><td> 0x????		</td><td> Instruction suivante		</td></tr></table>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder"><div class="" style="background-color:#99FFFF;margin-top:1cm;margin-bottom:1cm;margin-left:0.25cm;margin-right:0.25cm"><strong>Testez vos comp&eacute;tences sur <a href="doc/Exercice5.html">Assembleur</a></strong></div></p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Le &micro;-code de l'instruction de saut relatif sera plac&eacute; &agrave; la &micro;@10 (en hexa&nbsp;!), il est donc n&eacute;cessaire de modifier la &micro;-s&eacute;quenceur  car apr&egrave;s le fetch l'&eacute;tat suivant d&eacute;pend du COP/SCO de l'instruction qui vient d'&ecirc;tre charg&eacute;e dans le RI. La machine &agrave; &eacute;tat du &micro;-s&eacute;quenceur devient celui de la figure  2.2.
<div class="centr&eacute;e"><embed src="doc/graphe-boucle-decode23f0.svg?echelle=0.8" type="image/svg+xml"></embed></div><div class="centr&eacute;e"> Fig 2.2  : La machine &agrave; &eacute;tat du &micro;-s&eacute;quenceur utilisant un &eacute;tat de decode pour identifier le &micro;-code &agrave; ex&eacute;cuter pour une instruction</div>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Pour permettre les &micro;-sauts conditionn&eacute;s, le cœur alimente le bus d'adresse d'une ROM dite de <i>transcodage</i> avec les 8 bits du COP/SCO comme indiqu&eacute; sur la figure  2.3 (cf Polycopi&eacute; Chapitre 7.3 et en particulier la page 182). La ROM de transcodage fournit en sortie la &micro;@08 correspondant &agrave; l'instruction qui peut &ecirc;tre utilis&eacute;e par le s&eacute;quenceur. Cette op&eacute;ration de d&eacute;codage de l'instruction (<i>decode</i> en anglais) occupe un cycle machine effectu&eacute; sur la &micro;@FF d&eacute;di&eacute;e au decode.
<div class="centr&eacute;e"><embed src="doc/Transcodaged627.svg?echelle=0.7" type="image/svg+xml"></embed></div><div class="centr&eacute;e"> Fig 2.3  : Exemple d'une instruction cod&eacute;e avec le COP/SCO = 0x02 que la ROM de transcodage  d&eacute;code par la &micro;@8 o&ugrave; le s&eacute;quenceur va sauter.</div>
</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder">Pour utiliser le simulateur avec plus d'informations affich&eacute;es, utilisez la commande de lancement en sp&eacute;cifiant l'option "-awt=awtEtape1"&nbsp;:
<div style="white-space:pre;font-family:monospace;">$ <span style="color:#000086;"><strong>lilas /arch/processeurComplet/ProcesseurComplet2015.lilas -awt=awtEtape1 -script=initEtape1 -test</strong></span>
	
</div>
	</p><p style="top:10pt;bottom:5mm;text-align:justify;" xmlns:url="http://whatever/java/java.net.URLEncoder"><div class="" style="background-color:#FFCCFF;margin-top:1cm;margin-bottom:1cm;margin-left:0.25cm;margin-right:0.25cm"><strong>Travail&nbsp;: Decode et l'instruction de saut</strong><i><p style="text-align:justify;"> Modifiez la &micro;-s&eacute;quence afin d'ajouter l'&eacute;tape de decodage (0xFF) et le &micro;-saut en remplissant la ROM de transcodage avec le d&eacute;codage du MOV Ra,Rb. 
	Une fois ce test pass&eacute;, assemblez le programme complet (avec le code ex&eacute;cutable du saut) et ajoutez le d&eacute;codage et le &micro;-code de l'instruction 
	de saut relatif (Le travail r&eacute;alis&eacute; par l'instruction de saut relatif <strong>B xx</strong> est simplement <strong>PC &larr; PC + xx</strong>, xx &eacute;tant une valeur sign&eacute;e sur 8 bits). Testez l'ensemble et sauvegardez bien l'ensemble des fichiers&nbsp;: ROM de &micro;-code, ROM de transcode et ROM du programme.</p></i></div></p></div></body>
<!-- Mirrored from srv-gei.insa-toulouse.fr/PubliToolGEI/Enseignements/SFO/MIC-3/Documents/gitSFOMIC3/APPSFOPROF/etape1/index.html?part=ID_PubliTool_N102E3 by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 31 May 2018 14:00:57 GMT -->
</html>